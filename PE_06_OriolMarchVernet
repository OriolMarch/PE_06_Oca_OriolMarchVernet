public class PE_06_OriolMarchVernet {

    // Constants del joc

    private final int BOARD_SIZE = 63;
    private final int MIN_PLAYERS = 2;
    private final int MAX_PLAYERS = 4;

    // Tipus de caselles
    private final int NORMAL    = 0;
    private final int GOOSE     = 1;
    private final int BRIDGE    = 2;
    private final int INN       = 3;
    private final int WELL      = 4;
    private final int LABYRINTH = 5;
    private final int PRISON    = 6;
    private final int DICE36    = 7;   // casella 26
    private final int DICE45    = 8;   // casella 53
    private final int DEATH     = 9;   // casella 58
    private final int GARDEN    = 10;  // casella 63

    private boolean gameFinished = false;

    // Tauler
    private int[] cellType;
    private String[] cellMessage;
    private int[] cellDestination;
    private int[] cellPenalty;

    // Jugadors
    private int playerCount;
    private String[] playerNames;
    private int[] playerPositions;
    private int[] playerBlockedTurns;
    private boolean[] isFirstTurn;

    // Regla del pou
    private int wellPrisoner = -1;

    // Scanner General
    private Scanner sc = new Scanner(System.in);

    // Fer una variable torn per controlar el torn dels jugadors,
    // i fer un bucle amb un for. Variable mesAlt.

    // Main

    public static void main(String[] args) {
        PE_06_OriolMarchVernet p = new PE_06_OriolMarchVernet();
        p.mainGame();
    }

    // Programa principal

   public void principal() {
        System.out.println("=== JOC DE L'OCA ===");
        initGame();

        while (!gameFinished) {
            playRound();
        }

        System.out.println("Fi del joc.");
    }

    public void initGame() {
        playerCount = readIntRange("Introdueix nombre de jugadors (2-4): ", MIN_PLAYERS, MAX_PLAYERS);

        playerNames = new String[playerCount];
        playerPositions = new int[playerCount];
        playerBlockedTurns = new int[playerCount];
        isFirstTurn = new boolean[playerCount];

        for (int i = 0; i < playerCount; i++) {
            playerNames[i] = readNonEmpty("Nom del jugador " + (i + 1) + ": ");
            playerPositions[i] = 0;
            playerBlockedTurns[i] = 0;
            isFirstTurn[i] = true;
        }

        initBoard();
    }

    public void initBoard() {
        // +1 perquè la posició 63 existeixi tal qual
        cellType = new int[BOARD_SIZE + 1];
        cellMessage = new String[BOARD_SIZE + 1];
        cellDestination = new int[BOARD_SIZE + 1];
        cellPenalty = new int[BOARD_SIZE + 1];

        for (int i = 0; i < cellType.length; i++) {
            cellType[i] = NORMAL;
            cellMessage[i] = "";
            cellDestination[i] = i;
            cellPenalty[i] = 0;
        }

        // Oques
        int[] oques = {5, 9, 14, 18, 23, 27, 32, 36, 41, 45, 50, 54, 59};
        for (int i = 0; i < oques.length; i++) {
            int pos = oques[i];
            cellType[pos] = GOOSE;
            cellMessage[pos] = "De oca en oca y tiro porque me toca.";
        }
}

// Ponts 6 - 12
        cellType[6] = BRIDGE;
        cellType[12] = BRIDGE;
        cellMessage[6] = "De puente a puente y tiro porque me lleva la corriente!";
        cellMessage[12] = "De puente a puente y tiro porque me lleva la corriente!";

        // (19): 1 torn
        cellType[19] = INN;
        cellPenalty[19] = 1;
        cellMessage[19] = "Fonda: perds 1 torn.";

        // Pou (31): 2 torns + regla especial
        cellType[31] = WELL;
        cellPenalty[31] = 2;
        cellMessage[31] = "Pou: quedes atrapat fins que hi caigui algú altre.";

        // Laberint (42): torna a 39
        cellType[42] = LABYRINTH;
        cellDestination[42] = 39;
        cellMessage[42] = "Laberint: retrocedeixes a la 39.";

        // Presó (52): 3 torns
        cellType[52] = PRISON;
        cellPenalty[52] = 3;
        cellMessage[52] = "Presó: perds 3 torns.";

        // Mort (58): inici
        cellType[58] = DEATH;
        cellDestination[58] = 0;
        cellMessage[58] = "Mort: Tornes al inici.";

        // Jardí (63): fi
        cellType[63] = GARDEN;
        cellMessage[63] = "Jardí de l'Oca. Has arribat!";

        // Primera tirada especial
        cellType[26] = DICE36;
        cellType[53] = DICE45;
    }

    public void playRound() {
        for (int turn = 0; turn < playerCount; turn++) {
            if (gameFinished) break;
            playTurn(turn);
        }
    }

    public void playTurn(int turn) {
        System.out.println("----------------------------------");
        System.out.println("Torn del jugador " + (turn + 1) + ": " + playerNames[turn]);

        // Si està bloquejat
        if (playerBlockedTurns[turn] > 0) {
            playerBlockedTurns[turn]--;
            System.out.println("Bloquejat. Torns restants: " + playerBlockedTurns[turn]);
            return;
        }

        boolean extraRoll;
        do {
            extraRoll = false;

            waitForTiro();

            int d1 = rollDie();
            int d2 = 0;

            if (playerPositions[turn] < 60) {
                d2 = rollDie();
                System.out.println("Has obtingut " + d1 + " i " + d2 + " = " + (d1 + d2));
            } else {
                System.out.println("Has obtingut " + d1);
            }

            // Regla especial: primera tirada (només a inici i amb 2 daus)
            if (isFirstTurn[turn] && playerPositions[turn] == 0 && d2 != 0) {
                if (isCombo(d1, d2, 3, 6)) {
                    System.out.println("De dado a dado y tiro porque me ha tocado. Vas a la 26!");
                    playerPositions[turn] = 26;
                    isFirstTurn[turn] = false;
                    extraRoll = applyCellEffect(turn); // per si profe vol cadena
                    checkWin(turn);
                    return;
                } else if (isCombo(d1, d2, 4, 5)) {
                    System.out.println("De dado a dado y tiro porque me ha tocado. Vas a la 53!");
                    playerPositions[turn] = 53;
                    isFirstTurn[turn] = false;
                    extraRoll = applyCellEffect(turn);
                    checkWin(turn);
                    return;
                }
            }
        }   
        
            isFirstTurn[turn] = false;

            int steps = d1 + d2;
            movePlayerWithBounce(turn, steps);

            extraRoll = applyCellEffect(turn);

            // si ha quedat bloquejat, s'acaba la cadena de tirades
            if (playerBlockedTurns[turn] > 0) extraRoll = false;

            checkWin(turn);

        } while (extraRoll && !gameFinished);
    }

    private void checkWin(int turn) {
        if (playerPositions[turn] == 63) {
            System.out.println("Ha guanyat " + playerNames[turn] + "!!");
            gameFinished = true;
        }
    }

    // Moviment amb “rebote”.
    public void movePlayerWithBounce(int turn, int steps) {
        int oldPos = playerPositions[turn];
        int newPos = oldPos + steps;

        if (newPos > 63) {
            int overshoot = newPos - 63;
            newPos = 63 - overshoot;
            System.out.println("T'has passat! Rebot i tornes enrere.");
        }

        playerPositions[turn] = newPos;
        System.out.println("Avances fins la casella " + newPos + ".");
    }

    // Retorna true si cal “tornar a tirar”
    public boolean applyCellEffect(int turn) {
        int pos = playerPositions[turn];
        int type = cellType[pos];

        if (!cellMessage[pos].equals("")) {
            System.out.println("Casella " + pos + ": " + cellMessage[pos]);
        }

        if (type == GOOSE) {
            int next = (pos == 59) ? 63 : findNextGoose(pos);
            if (next != -1) {
                playerPositions[turn] = next;
                System.out.println("De oca a oca... vas a la casella " + next + ".");
                return true; // torna a tirar
            }
            return false;

        } else if (type == BRIDGE) {
            playerPositions[turn] = (pos == 6) ? 12 : 6;
            System.out.println("Pont! Ara ets a la casella " + playerPositions[turn] + ".");
            return true; // torna a tirar

        } else if (type == INN || type == PRISON) {
            playerBlockedTurns[turn] = cellPenalty[pos];
            System.out.println("Penalització: perds " + cellPenalty[pos] + " torn(s).");
            return false;

        } else if (type == WELL) {
            // Si hi havia algú al pou, surt quan un altre cau
            if (wellPrisoner != -1 && wellPrisoner != turn) {
                System.out.println("El jugador " + playerNames[wellPrisoner] + " surt del pou!");
                playerBlockedTurns[wellPrisoner] = 0;
            }
            wellPrisoner = turn;
            playerBlockedTurns[turn] = cellPenalty[pos];
            System.out.println("Et quedes " + cellPenalty[pos] + " torn(s) bloquejat.");
            return false;

        } else if (type == LABYRINTH || type == DEATH) {
            int dest = cellDestination[pos];
            playerPositions[turn] = dest;
            System.out.println("Efecte: vas a la casella " + dest + ".");
            return false;
        }

        return false;
    }

    public int findNextGoose(int pos) {
        int[] oques = {5, 9, 14, 18, 23, 27, 32, 36, 41, 45, 50, 54, 59};
        for (int i = 0; i < oques.length; i++) {
            if (oques[i] > pos) return oques[i];
        }
        return -1;
    }

    private boolean isCombo(int d1, int d2, int a, int b) {
        return (d1 == a && d2 == b) || (d1 == b && d2 == a);
    }

    public void waitForTiro() {
        String txt = "";
        System.out.println("Escriu 'tiro' per tirar els daus.");
        while (!txt.equalsIgnoreCase("tiro")) {
            System.out.print(">> ");
            txt = sc.nextLine();
        }
    }

    public int rollDie() {
        return (int)(Math.random() * 6) + 1;
    }

    // Lectura d'enters amb control d'errors (estil PE_05)
    public int readInt(Scanner sc, String message) {
        int value = 0;
        boolean ok = false;

        while (!ok) {
            System.out.print(message);
            try {
                value = sc.nextInt();
                sc.nextLine(); // neteja buffer
                ok = true;
            } catch (InputMismatchException e) {
                System.out.println("Error: introdueix un número enter.");
                sc.nextLine();
            }
        }
        return value;
    }

    public int readIntRange(String message, int min, int max) {
        int value = readInt(sc, message);
        while (value < min || value > max) {
            System.out.println("Valor no vàlid. Ha d'estar entre " + min + " i " + max + ".");
            value = readInt(sc, message);
        }
        return value;
    }

    public String readNonEmpty(String msg) {
        String txt = "";
        while (txt.trim().equals("")) {
            System.out.print(msg);
            txt = sc.nextLine();
            if (txt.trim().equals("")) {
                System.out.println("No pot estar buit.");
            }
        }
        return txt;
    }